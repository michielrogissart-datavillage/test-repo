// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes AnyType as json.
func (s AnyType) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringAnyType:
		e.Str(s.String)
	case Float64AnyType:
		e.Float64(s.Float64)
	case IntAnyType:
		e.Int(s.Int)
	case BoolAnyType:
		e.Bool(s.Bool)
	case AnyArrayAnyType:
		e.ArrStart()
		for _, elem := range s.AnyArray {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	case AnyType5AnyType:
		s.AnyType5.Encode(e)
	}
}

// Decode decodes AnyType from json.
func (s *AnyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnyType to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.AnyArray = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.AnyArray = append(s.AnyArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = AnyArrayAnyType
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolAnyType
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntAnyType
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64AnyType
		}
	case jx.Object:
		if err := s.AnyType5.Decode(d); err != nil {
			return err
		}
		s.Type = AnyType5AnyType
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAnyType
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnyType5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnyType5) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAnyType5 = [0]string{}

// Decode decodes AnyType5 from json.
func (s *AnyType5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnyType5 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AnyType5")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnyType5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnyType5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiServer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("location")
		json.EncodeURI(e, s.Location)
	}
}

var jsonFieldsNameOfApiServer = [2]string{
	0: "type",
	1: "location",
}

// Decode decodes ApiServer from json.
func (s *ApiServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiServer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Location = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiServer) {
					name = jsonFieldsNameOfApiServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthorativeDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthorativeDefinition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfAuthorativeDefinition = [2]string{
	0: "url",
	1: "type",
}

// Decode decodes AuthorativeDefinition from json.
func (s *AuthorativeDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorativeDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthorativeDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthorativeDefinition) {
					name = jsonFieldsNameOfAuthorativeDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthorativeDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthorativeDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
}

var jsonFieldsNameOfBadRequestError = [1]string{
	0: "error_message",
}

// Decode decodes BadRequestError from json.
func (s *BadRequestError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBadRequestError) {
					name = jsonFieldsNameOfBadRequestError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeProvider) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeProvider = [3]string{
	0: "role",
	1: "settings",
	2: "source",
}

// Decode decodes CodeProvider from json.
func (s *CodeProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeProviderSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeProviderSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeProviderSettings = [1]string{
	0: "description",
}

// Decode decodes CodeProviderSettings from json.
func (s *CodeProviderSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeProviderSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeProviderSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeProviderSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeProviderSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeProviderSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeProviderSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("registry")
		e.Str(s.Registry)
	}
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeProviderSource = [4]string{
	0: "registry",
	1: "image",
	2: "tag",
	3: "secret",
}

// Decode decodes CodeProviderSource from json.
func (s *CodeProviderSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeProviderSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "registry":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Registry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registry\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeProviderSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeProviderSource) {
					name = jsonFieldsNameOfCodeProviderSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeProviderSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeProviderSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaborationSpace) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaborationSpace) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Collaborators != nil {
			e.FieldStart("collaborators")
			e.ArrStart()
			for _, elem := range s.Collaborators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCollaborationSpace = [4]string{
	0: "name",
	1: "category",
	2: "id",
	3: "collaborators",
}

// Decode decodes CollaborationSpace from json.
func (s *CollaborationSpace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaborationSpace to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators = make([]Collaborator, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Collaborator
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Collaborators = append(s.Collaborators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaborationSpace")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaborationSpace) {
					name = jsonFieldsNameOfCollaborationSpace[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaborationSpace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaborationSpace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaborationSpaceCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaborationSpaceCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Collaborators != nil {
			e.FieldStart("collaborators")
			e.ArrStart()
			for _, elem := range s.Collaborators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCollaborationSpaceCreate = [3]string{
	0: "name",
	1: "category",
	2: "collaborators",
}

// Decode decodes CollaborationSpaceCreate from json.
func (s *CollaborationSpaceCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaborationSpaceCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators = make([]CollaboratorCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CollaboratorCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Collaborators = append(s.Collaborators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaborationSpaceCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaborationSpaceCreate) {
					name = jsonFieldsNameOfCollaborationSpaceCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaborationSpaceCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaborationSpaceCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaborationSpaceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaborationSpaceUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Collaborators != nil {
			e.FieldStart("collaborators")
			e.ArrStart()
			for _, elem := range s.Collaborators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCollaborationSpaceUpdate = [3]string{
	0: "name",
	1: "category",
	2: "collaborators",
}

// Decode decodes CollaborationSpaceUpdate from json.
func (s *CollaborationSpaceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaborationSpaceUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators = make([]CollaboratorCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CollaboratorCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Collaborators = append(s.Collaborators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaborationSpaceUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaborationSpaceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaborationSpaceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Collaborator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Collaborator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfCollaborator = [5]string{
	0: "clientId",
	1: "name",
	2: "label",
	3: "configuration",
	4: "id",
}

// Decode decodes Collaborator from json.
func (s *Collaborator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Collaborator to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Collaborator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaborator) {
					name = jsonFieldsNameOfCollaborator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Collaborator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Collaborator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CollaboratorConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CollaboratorConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes CollaboratorConfiguration from json.
func (s *CollaboratorConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaboratorCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaboratorCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfCollaboratorCreate = [4]string{
	0: "clientId",
	1: "name",
	2: "label",
	3: "configuration",
}

// Decode decodes CollaboratorCreate from json.
func (s *CollaboratorCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorCreate to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaboratorCreate) {
					name = jsonFieldsNameOfCollaboratorCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaboratorCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CollaboratorCreateConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CollaboratorCreateConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes CollaboratorCreateConfiguration from json.
func (s *CollaboratorCreateConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorCreateConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorCreateConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorCreateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorCreateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorCreateSum as json.
func (s CollaboratorCreateSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CollaboratorCreateSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CodeProviderCollaboratorCreateSum:
		e.FieldStart("role")
		e.Str("CodeProvider")
		{
			s := s.CodeProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
			{
				if s.Source.Set {
					e.FieldStart("source")
					s.Source.Encode(e)
				}
			}
		}
	case DataConsumerCollaboratorCreateSum:
		e.FieldStart("role")
		e.Str("DataConsumer")
		{
			s := s.DataConsumer
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	case DataProviderCollaboratorCreateSum:
		e.FieldStart("role")
		e.Str("DataProvider")
		{
			s := s.DataProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	}
}

// Decode decodes CollaboratorCreateSum from json.
func (s *CollaboratorCreateSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorCreateSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "role":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CodeProvider":
					s.Type = CodeProviderCollaboratorCreateSum
					found = true
				case "DataConsumer":
					s.Type = DataConsumerCollaboratorCreateSum
					found = true
				case "DataProvider":
					s.Type = DataProviderCollaboratorCreateSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CodeProviderCollaboratorCreateSum:
		if err := s.CodeProvider.Decode(d); err != nil {
			return err
		}
	case DataProviderCollaboratorCreateSum:
		if err := s.DataProvider.Decode(d); err != nil {
			return err
		}
	case DataConsumerCollaboratorCreateSum:
		if err := s.DataConsumer.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorCreateSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorCreateSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorSum as json.
func (s CollaboratorSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CollaboratorSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CodeProviderCollaboratorSum:
		e.FieldStart("role")
		e.Str("CodeProvider")
		{
			s := s.CodeProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
			{
				if s.Source.Set {
					e.FieldStart("source")
					s.Source.Encode(e)
				}
			}
		}
	case DataConsumerCollaboratorSum:
		e.FieldStart("role")
		e.Str("DataConsumer")
		{
			s := s.DataConsumer
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	case DataProviderCollaboratorSum:
		e.FieldStart("role")
		e.Str("DataProvider")
		{
			s := s.DataProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	}
}

// Decode decodes CollaboratorSum from json.
func (s *CollaboratorSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "role":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CodeProvider":
					s.Type = CodeProviderCollaboratorSum
					found = true
				case "DataConsumer":
					s.Type = DataConsumerCollaboratorSum
					found = true
				case "DataProvider":
					s.Type = DataProviderCollaboratorSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CodeProviderCollaboratorSum:
		if err := s.CodeProvider.Decode(d); err != nil {
			return err
		}
	case DataProviderCollaboratorSum:
		if err := s.DataProvider.Decode(d); err != nil {
			return err
		}
	case DataConsumerCollaboratorSum:
		if err := s.DataConsumer.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaboratorUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaboratorUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ClientId.Set {
			e.FieldStart("clientId")
			s.ClientId.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfCollaboratorUpdate = [4]string{
	0: "clientId",
	1: "name",
	2: "label",
	3: "configuration",
}

// Decode decodes CollaboratorUpdate from json.
func (s *CollaboratorUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorUpdate to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientId":
			if err := func() error {
				s.ClientId.Reset()
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaboratorUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CollaboratorUpdateConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CollaboratorUpdateConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes CollaboratorUpdateConfiguration from json.
func (s *CollaboratorUpdateConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorUpdateConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorUpdateConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorUpdateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorUpdateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorUpdateSum as json.
func (s CollaboratorUpdateSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CollaboratorUpdateSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CodeProviderCollaboratorUpdateSum:
		e.FieldStart("role")
		e.Str("CodeProvider")
		{
			s := s.CodeProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
			{
				if s.Source.Set {
					e.FieldStart("source")
					s.Source.Encode(e)
				}
			}
		}
	case DataConsumerCollaboratorUpdateSum:
		e.FieldStart("role")
		e.Str("DataConsumer")
		{
			s := s.DataConsumer
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	case DataProviderCollaboratorUpdateSum:
		e.FieldStart("role")
		e.Str("DataProvider")
		{
			s := s.DataProvider
			{
				if s.Settings.Set {
					e.FieldStart("settings")
					s.Settings.Encode(e)
				}
			}
		}
	}
}

// Decode decodes CollaboratorUpdateSum from json.
func (s *CollaboratorUpdateSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorUpdateSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "role":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "CodeProvider":
					s.Type = CodeProviderCollaboratorUpdateSum
					found = true
				case "DataConsumer":
					s.Type = DataConsumerCollaboratorUpdateSum
					found = true
				case "DataProvider":
					s.Type = DataProviderCollaboratorUpdateSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CodeProviderCollaboratorUpdateSum:
		if err := s.CodeProvider.Decode(d); err != nil {
			return err
		}
	case DataProviderCollaboratorUpdateSum:
		if err := s.DataProvider.Decode(d); err != nil {
			return err
		}
	case DataConsumerCollaboratorUpdateSum:
		if err := s.DataConsumer.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CollaboratorUpdateSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorUpdateSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatedResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatedResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfCreatedResource = [1]string{
	0: "id",
}

// Decode decodes CreatedResource from json.
func (s *CreatedResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatedResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatedResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatedResource) {
					name = jsonFieldsNameOfCreatedResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomProperty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomProperty) encodeFields(e *jx.Encoder) {
	{
		if s.Property.Set {
			e.FieldStart("property")
			s.Property.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfCustomProperty = [2]string{
	0: "property",
	1: "value",
}

// Decode decodes CustomProperty from json.
func (s *CustomProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomProperty to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "property":
			if err := func() error {
				s.Property.Reset()
				if err := s.Property.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"property\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomProperty")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomServer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Account.Set {
			e.FieldStart("account")
			s.Account.Encode(e)
		}
	}
	{
		if s.Catalog.Set {
			e.FieldStart("catalog")
			s.Catalog.Encode(e)
		}
	}
	{
		if s.Database.Set {
			e.FieldStart("database")
			s.Database.Encode(e)
		}
	}
	{
		if s.Dataset.Set {
			e.FieldStart("dataset")
			s.Dataset.Encode(e)
		}
	}
	{
		if s.Delimiter.Set {
			e.FieldStart("delimiter")
			s.Delimiter.Encode(e)
		}
	}
	{
		if s.EndpointUrl.Set {
			e.FieldStart("endpointUrl")
			s.EndpointUrl.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Project.Set {
			e.FieldStart("project")
			s.Project.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.RegionName.Set {
			e.FieldStart("regionName")
			s.RegionName.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{
		if s.ServiceName.Set {
			e.FieldStart("serviceName")
			s.ServiceName.Encode(e)
		}
	}
	{
		if s.StagingDir.Set {
			e.FieldStart("stagingDir")
			s.StagingDir.Encode(e)
		}
	}
	{
		if s.Warehouse.Set {
			e.FieldStart("warehouse")
			s.Warehouse.Encode(e)
		}
	}
}

var jsonFieldsNameOfCustomServer = [19]string{
	0:  "type",
	1:  "location",
	2:  "path",
	3:  "account",
	4:  "catalog",
	5:  "database",
	6:  "dataset",
	7:  "delimiter",
	8:  "endpointUrl",
	9:  "format",
	10: "host",
	11: "port",
	12: "project",
	13: "region",
	14: "regionName",
	15: "schema",
	16: "serviceName",
	17: "stagingDir",
	18: "warehouse",
}

// Decode decodes CustomServer from json.
func (s *CustomServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomServer to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "account":
			if err := func() error {
				s.Account.Reset()
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "catalog":
			if err := func() error {
				s.Catalog.Reset()
				if err := s.Catalog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"catalog\"")
			}
		case "database":
			if err := func() error {
				s.Database.Reset()
				if err := s.Database.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database\"")
			}
		case "dataset":
			if err := func() error {
				s.Dataset.Reset()
				if err := s.Dataset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset\"")
			}
		case "delimiter":
			if err := func() error {
				s.Delimiter.Reset()
				if err := s.Delimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delimiter\"")
			}
		case "endpointUrl":
			if err := func() error {
				s.EndpointUrl.Reset()
				if err := s.EndpointUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpointUrl\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "project":
			if err := func() error {
				s.Project.Reset()
				if err := s.Project.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "regionName":
			if err := func() error {
				s.RegionName.Reset()
				if err := s.RegionName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionName\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "serviceName":
			if err := func() error {
				s.ServiceName.Reset()
				if err := s.ServiceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceName\"")
			}
		case "stagingDir":
			if err := func() error {
				s.StagingDir.Reset()
				if err := s.StagingDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stagingDir\"")
			}
		case "warehouse":
			if err := func() error {
				s.Warehouse.Reset()
				if err := s.Warehouse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warehouse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomServer) {
					name = jsonFieldsNameOfCustomServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataConsumer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataConsumer) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataConsumer = [2]string{
	0: "role",
	1: "settings",
}

// Decode decodes DataConsumer from json.
func (s *DataConsumer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataConsumer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataConsumer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataConsumer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataConsumer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataConsumerSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataConsumerSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataConsumerSettings = [1]string{
	0: "description",
}

// Decode decodes DataConsumerSettings from json.
func (s *DataConsumerSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataConsumerSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataConsumerSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataConsumerSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataConsumerSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContract) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContract) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		e.FieldStart("dataContract")
		s.DataContract.Encode(e)
	}
}

var jsonFieldsNameOfDataContract = [3]string{
	0: "id",
	1: "clientId",
	2: "dataContract",
}

// Decode decodes DataContract from json.
func (s *DataContract) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContract to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "dataContract":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DataContract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataContract\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContract")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataContract) {
					name = jsonFieldsNameOfDataContract[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContract) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContract) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContractCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContractCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("apiVersion")
		s.ApiVersion.Encode(e)
	}
	{
		e.FieldStart("kind")
		s.Kind.Encode(e)
	}
	{
		if s.Tenant.Set {
			e.FieldStart("tenant")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataProduct.Set {
			e.FieldStart("dataProduct")
			s.DataProduct.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.SlaDefaultElement.Set {
			e.FieldStart("slaDefaultElement")
			s.SlaDefaultElement.Encode(e)
		}
	}
	{
		if s.ContractCreatedTs.Set {
			e.FieldStart("contractCreatedTs")
			s.ContractCreatedTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			e.ArrStart()
			for _, elem := range s.Schema {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDataContractCreate = [16]string{
	0:  "version",
	1:  "name",
	2:  "status",
	3:  "id",
	4:  "apiVersion",
	5:  "kind",
	6:  "tenant",
	7:  "tags",
	8:  "dataProduct",
	9:  "description",
	10: "price",
	11: "domain",
	12: "slaDefaultElement",
	13: "contractCreatedTs",
	14: "servers",
	15: "schema",
}

// Decode decodes DataContractCreate from json.
func (s *DataContractCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractCreate to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "apiVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "dataProduct":
			if err := func() error {
				s.DataProduct.Reset()
				if err := s.DataProduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataProduct\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "slaDefaultElement":
			if err := func() error {
				s.SlaDefaultElement.Reset()
				if err := s.SlaDefaultElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slaDefaultElement\"")
			}
		case "contractCreatedTs":
			if err := func() error {
				s.ContractCreatedTs.Reset()
				if err := s.ContractCreatedTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contractCreatedTs\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]ODCSServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ODCSServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = make([]SchemaCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SchemaCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schema = append(s.Schema, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContractCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataContractCreate) {
					name = jsonFieldsNameOfDataContractCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContractCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractCreateApiVersion as json.
func (s DataContractCreateApiVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractCreateApiVersion from json.
func (s *DataContractCreateApiVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractCreateApiVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractCreateApiVersion(v) {
	case DataContractCreateApiVersionV300:
		*s = DataContractCreateApiVersionV300
	case DataContractCreateApiVersionV222:
		*s = DataContractCreateApiVersionV222
	case DataContractCreateApiVersionV221:
		*s = DataContractCreateApiVersionV221
	case DataContractCreateApiVersionV220:
		*s = DataContractCreateApiVersionV220
	default:
		*s = DataContractCreateApiVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractCreateApiVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractCreateApiVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractCreateKind as json.
func (s DataContractCreateKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractCreateKind from json.
func (s *DataContractCreateKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractCreateKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractCreateKind(v) {
	case DataContractCreateKindDataContract:
		*s = DataContractCreateKindDataContract
	default:
		*s = DataContractCreateKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractCreateKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractCreateKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContractDataContract) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContractDataContract) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("apiVersion")
		s.ApiVersion.Encode(e)
	}
	{
		e.FieldStart("kind")
		s.Kind.Encode(e)
	}
	{
		if s.Tenant.Set {
			e.FieldStart("tenant")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataProduct.Set {
			e.FieldStart("dataProduct")
			s.DataProduct.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.SlaDefaultElement.Set {
			e.FieldStart("slaDefaultElement")
			s.SlaDefaultElement.Encode(e)
		}
	}
	{
		if s.ContractCreatedTs.Set {
			e.FieldStart("contractCreatedTs")
			s.ContractCreatedTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			e.ArrStart()
			for _, elem := range s.Schema {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDataContractDataContract = [16]string{
	0:  "version",
	1:  "name",
	2:  "status",
	3:  "id",
	4:  "apiVersion",
	5:  "kind",
	6:  "tenant",
	7:  "tags",
	8:  "dataProduct",
	9:  "description",
	10: "price",
	11: "domain",
	12: "slaDefaultElement",
	13: "contractCreatedTs",
	14: "servers",
	15: "schema",
}

// Decode decodes DataContractDataContract from json.
func (s *DataContractDataContract) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractDataContract to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "apiVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "dataProduct":
			if err := func() error {
				s.DataProduct.Reset()
				if err := s.DataProduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataProduct\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "slaDefaultElement":
			if err := func() error {
				s.SlaDefaultElement.Reset()
				if err := s.SlaDefaultElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slaDefaultElement\"")
			}
		case "contractCreatedTs":
			if err := func() error {
				s.ContractCreatedTs.Reset()
				if err := s.ContractCreatedTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contractCreatedTs\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]ODCSServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ODCSServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = make([]Schema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Schema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schema = append(s.Schema, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContractDataContract")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataContractDataContract) {
					name = jsonFieldsNameOfDataContractDataContract[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContractDataContract) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractDataContract) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractDataContractApiVersion as json.
func (s DataContractDataContractApiVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractDataContractApiVersion from json.
func (s *DataContractDataContractApiVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractDataContractApiVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractDataContractApiVersion(v) {
	case DataContractDataContractApiVersionV300:
		*s = DataContractDataContractApiVersionV300
	case DataContractDataContractApiVersionV222:
		*s = DataContractDataContractApiVersionV222
	case DataContractDataContractApiVersionV221:
		*s = DataContractDataContractApiVersionV221
	case DataContractDataContractApiVersionV220:
		*s = DataContractDataContractApiVersionV220
	default:
		*s = DataContractDataContractApiVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractDataContractApiVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractDataContractApiVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractDataContractKind as json.
func (s DataContractDataContractKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractDataContractKind from json.
func (s *DataContractDataContractKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractDataContractKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractDataContractKind(v) {
	case DataContractDataContractKindDataContract:
		*s = DataContractDataContractKindDataContract
	default:
		*s = DataContractDataContractKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractDataContractKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractDataContractKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContractSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContractSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		e.FieldStart("dataContractSummary")
		s.DataContractSummary.Encode(e)
	}
}

var jsonFieldsNameOfDataContractSummary = [3]string{
	0: "id",
	1: "clientId",
	2: "dataContractSummary",
}

// Decode decodes DataContractSummary from json.
func (s *DataContractSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "dataContractSummary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DataContractSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataContractSummary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContractSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataContractSummary) {
					name = jsonFieldsNameOfDataContractSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContractSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContractSummaryDataContractSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContractSummaryDataContractSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDataContractSummaryDataContractSummary = [3]string{
	0: "version",
	1: "name",
	2: "status",
}

// Decode decodes DataContractSummaryDataContractSummary from json.
func (s *DataContractSummaryDataContractSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractSummaryDataContractSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContractSummaryDataContractSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataContractSummaryDataContractSummary) {
					name = jsonFieldsNameOfDataContractSummaryDataContractSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContractSummaryDataContractSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractSummaryDataContractSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataContractUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataContractUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Tenant.Set {
			e.FieldStart("tenant")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataProduct.Set {
			e.FieldStart("dataProduct")
			s.DataProduct.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.SlaDefaultElement.Set {
			e.FieldStart("slaDefaultElement")
			s.SlaDefaultElement.Encode(e)
		}
	}
	{
		if s.ContractCreatedTs.Set {
			e.FieldStart("contractCreatedTs")
			s.ContractCreatedTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			e.ArrStart()
			for _, elem := range s.Schema {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDataContractUpdate = [16]string{
	0:  "version",
	1:  "name",
	2:  "status",
	3:  "id",
	4:  "apiVersion",
	5:  "kind",
	6:  "tenant",
	7:  "tags",
	8:  "dataProduct",
	9:  "description",
	10: "price",
	11: "domain",
	12: "slaDefaultElement",
	13: "contractCreatedTs",
	14: "servers",
	15: "schema",
}

// Decode decodes DataContractUpdate from json.
func (s *DataContractUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractUpdate to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "dataProduct":
			if err := func() error {
				s.DataProduct.Reset()
				if err := s.DataProduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataProduct\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "slaDefaultElement":
			if err := func() error {
				s.SlaDefaultElement.Reset()
				if err := s.SlaDefaultElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slaDefaultElement\"")
			}
		case "contractCreatedTs":
			if err := func() error {
				s.ContractCreatedTs.Reset()
				if err := s.ContractCreatedTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contractCreatedTs\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]ODCSServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ODCSServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = make([]SchemaCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SchemaCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schema = append(s.Schema, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataContractUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataContractUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractUpdateApiVersion as json.
func (s DataContractUpdateApiVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractUpdateApiVersion from json.
func (s *DataContractUpdateApiVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractUpdateApiVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractUpdateApiVersion(v) {
	case DataContractUpdateApiVersionV300:
		*s = DataContractUpdateApiVersionV300
	case DataContractUpdateApiVersionV222:
		*s = DataContractUpdateApiVersionV222
	case DataContractUpdateApiVersionV221:
		*s = DataContractUpdateApiVersionV221
	case DataContractUpdateApiVersionV220:
		*s = DataContractUpdateApiVersionV220
	default:
		*s = DataContractUpdateApiVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractUpdateApiVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractUpdateApiVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractUpdateKind as json.
func (s DataContractUpdateKind) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataContractUpdateKind from json.
func (s *DataContractUpdateKind) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataContractUpdateKind to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataContractUpdateKind(v) {
	case DataContractUpdateKindDataContract:
		*s = DataContractUpdateKindDataContract
	default:
		*s = DataContractUpdateKind(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataContractUpdateKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataContractUpdateKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataProvider) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataProvider = [2]string{
	0: "role",
	1: "settings",
}

// Decode decodes DataProvider from json.
func (s *DataProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataProviderSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataProviderSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataProviderSettings = [1]string{
	0: "description",
}

// Decode decodes DataProviderSettings from json.
func (s *DataProviderSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataProviderSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataProviderSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataProviderSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataProviderSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQuality as json.
func (s DataQuality) Encode(e *jx.Encoder) {
	unwrapped := []DataQualityItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes DataQuality from json.
func (s *DataQuality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQuality to nil")
	}
	var unwrapped []DataQualityItem
	if err := func() error {
		unwrapped = make([]DataQualityItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DataQualityItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DataQuality(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataQualityItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataQualityItem) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessImpact.Set {
			e.FieldStart("businessImpact")
			s.BusinessImpact.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Dimension.Set {
			e.FieldStart("dimension")
			s.Dimension.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Schedule.Set {
			e.FieldStart("schedule")
			s.Schedule.Encode(e)
		}
	}
	{
		if s.Scheduler.Set {
			e.FieldStart("scheduler")
			s.Scheduler.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AuthoritativeDefinitions != nil {
			e.FieldStart("authoritativeDefinitions")
			e.ArrStart()
			for _, elem := range s.AuthoritativeDefinitions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CustomProperties != nil {
			e.FieldStart("customProperties")
			e.ArrStart()
			for _, elem := range s.CustomProperties {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfDataQualityItem = [12]string{
	0:  "businessImpact",
	1:  "description",
	2:  "dimension",
	3:  "method",
	4:  "name",
	5:  "schedule",
	6:  "scheduler",
	7:  "severity",
	8:  "unit",
	9:  "tags",
	10: "authoritativeDefinitions",
	11: "customProperties",
}

// Decode decodes DataQualityItem from json.
func (s *DataQualityItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualityItem to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "businessImpact":
			if err := func() error {
				s.BusinessImpact.Reset()
				if err := s.BusinessImpact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessImpact\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "dimension":
			if err := func() error {
				s.Dimension.Reset()
				if err := s.Dimension.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dimension\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "schedule":
			if err := func() error {
				s.Schedule.Reset()
				if err := s.Schedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "scheduler":
			if err := func() error {
				s.Scheduler.Reset()
				if err := s.Scheduler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduler\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "authoritativeDefinitions":
			if err := func() error {
				s.AuthoritativeDefinitions = make([]AuthorativeDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthorativeDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AuthoritativeDefinitions = append(s.AuthoritativeDefinitions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authoritativeDefinitions\"")
			}
		case "customProperties":
			if err := func() error {
				s.CustomProperties = make([]CustomProperty, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomProperty
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomProperties = append(s.CustomProperties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customProperties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataQualityItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataQualityItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualityItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualityItemDimension as json.
func (s DataQualityItemDimension) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataQualityItemDimension from json.
func (s *DataQualityItemDimension) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualityItemDimension to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataQualityItemDimension(v) {
	case DataQualityItemDimensionAccuracy:
		*s = DataQualityItemDimensionAccuracy
	case DataQualityItemDimensionCompleteness:
		*s = DataQualityItemDimensionCompleteness
	case DataQualityItemDimensionConformity:
		*s = DataQualityItemDimensionConformity
	case DataQualityItemDimensionConsistency:
		*s = DataQualityItemDimensionConsistency
	case DataQualityItemDimensionCoverage:
		*s = DataQualityItemDimensionCoverage
	case DataQualityItemDimensionTimeliness:
		*s = DataQualityItemDimensionTimeliness
	case DataQualityItemDimensionUniqueness:
		*s = DataQualityItemDimensionUniqueness
	default:
		*s = DataQualityItemDimension(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataQualityItemDimension) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualityItemDimension) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualityItemSum as json.
func (s DataQualityItemSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s DataQualityItemSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DataQualityLibraryDataQualityItemSum:
		e.FieldStart("type")
		e.Str("library")
		{
			s := s.DataQualityLibrary
			{
				e.FieldStart("rule")
				e.Str(s.Rule)
			}
			{
				if len(s.MustBe) != 0 {
					e.FieldStart("mustBe")
					e.Raw(s.MustBe)
				}
			}
			{
				if len(s.MustNotBe) != 0 {
					e.FieldStart("mustNotBe")
					e.Raw(s.MustNotBe)
				}
			}
			{
				if s.MustBeGreaterThan.Set {
					e.FieldStart("mustBeGreaterThan")
					s.MustBeGreaterThan.Encode(e)
				}
			}
			{
				if s.MustBeGreaterOrEqualTo.Set {
					e.FieldStart("mustBeGreaterOrEqualTo")
					s.MustBeGreaterOrEqualTo.Encode(e)
				}
			}
			{
				if s.MustBeLessThan.Set {
					e.FieldStart("mustBeLessThan")
					s.MustBeLessThan.Encode(e)
				}
			}
			{
				if s.MustBeLessOrEqualTo.Set {
					e.FieldStart("mustBeLessOrEqualTo")
					s.MustBeLessOrEqualTo.Encode(e)
				}
			}
			{
				if s.MustBeBetween.Set {
					e.FieldStart("mustBeBetween")
					s.MustBeBetween.Encode(e)
				}
			}
			{
				if s.MustNotBeBetween.Set {
					e.FieldStart("mustNotBeBetween")
					s.MustNotBeBetween.Encode(e)
				}
			}
		}
	case DataQualitySqlDataQualityItemSum:
		e.FieldStart("type")
		e.Str("sql")
		{
			s := s.DataQualitySql
			{
				e.FieldStart("query")
				e.Str(s.Query)
			}
		}
	}
}

// Decode decodes DataQualityItemSum from json.
func (s *DataQualityItemSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualityItemSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "library":
					s.Type = DataQualityLibraryDataQualityItemSum
					found = true
				case "sql":
					s.Type = DataQualitySqlDataQualityItemSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DataQualityLibraryDataQualityItemSum:
		if err := s.DataQualityLibrary.Decode(d); err != nil {
			return err
		}
	case DataQualitySqlDataQualityItemSum:
		if err := s.DataQualitySql.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataQualityItemSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualityItemSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataQualityLibrary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataQualityLibrary) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("rule")
		e.Str(s.Rule)
	}
	{
		if len(s.MustBe) != 0 {
			e.FieldStart("mustBe")
			e.Raw(s.MustBe)
		}
	}
	{
		if len(s.MustNotBe) != 0 {
			e.FieldStart("mustNotBe")
			e.Raw(s.MustNotBe)
		}
	}
	{
		if s.MustBeGreaterThan.Set {
			e.FieldStart("mustBeGreaterThan")
			s.MustBeGreaterThan.Encode(e)
		}
	}
	{
		if s.MustBeGreaterOrEqualTo.Set {
			e.FieldStart("mustBeGreaterOrEqualTo")
			s.MustBeGreaterOrEqualTo.Encode(e)
		}
	}
	{
		if s.MustBeLessThan.Set {
			e.FieldStart("mustBeLessThan")
			s.MustBeLessThan.Encode(e)
		}
	}
	{
		if s.MustBeLessOrEqualTo.Set {
			e.FieldStart("mustBeLessOrEqualTo")
			s.MustBeLessOrEqualTo.Encode(e)
		}
	}
	{
		if s.MustBeBetween.Set {
			e.FieldStart("mustBeBetween")
			s.MustBeBetween.Encode(e)
		}
	}
	{
		if s.MustNotBeBetween.Set {
			e.FieldStart("mustNotBeBetween")
			s.MustNotBeBetween.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataQualityLibrary = [10]string{
	0: "type",
	1: "rule",
	2: "mustBe",
	3: "mustNotBe",
	4: "mustBeGreaterThan",
	5: "mustBeGreaterOrEqualTo",
	6: "mustBeLessThan",
	7: "mustBeLessOrEqualTo",
	8: "mustBeBetween",
	9: "mustNotBeBetween",
}

// Decode decodes DataQualityLibrary from json.
func (s *DataQualityLibrary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualityLibrary to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "mustBe":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MustBe = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBe\"")
			}
		case "mustNotBe":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MustNotBe = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustNotBe\"")
			}
		case "mustBeGreaterThan":
			if err := func() error {
				s.MustBeGreaterThan.Reset()
				if err := s.MustBeGreaterThan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBeGreaterThan\"")
			}
		case "mustBeGreaterOrEqualTo":
			if err := func() error {
				s.MustBeGreaterOrEqualTo.Reset()
				if err := s.MustBeGreaterOrEqualTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBeGreaterOrEqualTo\"")
			}
		case "mustBeLessThan":
			if err := func() error {
				s.MustBeLessThan.Reset()
				if err := s.MustBeLessThan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBeLessThan\"")
			}
		case "mustBeLessOrEqualTo":
			if err := func() error {
				s.MustBeLessOrEqualTo.Reset()
				if err := s.MustBeLessOrEqualTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBeLessOrEqualTo\"")
			}
		case "mustBeBetween":
			if err := func() error {
				s.MustBeBetween.Reset()
				if err := s.MustBeBetween.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustBeBetween\"")
			}
		case "mustNotBeBetween":
			if err := func() error {
				s.MustNotBeBetween.Reset()
				if err := s.MustNotBeBetween.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mustNotBeBetween\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataQualityLibrary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataQualityLibrary) {
					name = jsonFieldsNameOfDataQualityLibrary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataQualityLibrary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualityLibrary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualityLibraryType as json.
func (s DataQualityLibraryType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataQualityLibraryType from json.
func (s *DataQualityLibraryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualityLibraryType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataQualityLibraryType(v) {
	case DataQualityLibraryTypeText:
		*s = DataQualityLibraryTypeText
	case DataQualityLibraryTypeLibrary:
		*s = DataQualityLibraryTypeLibrary
	case DataQualityLibraryTypeSQL:
		*s = DataQualityLibraryTypeSQL
	case DataQualityLibraryTypeCustom:
		*s = DataQualityLibraryTypeCustom
	default:
		*s = DataQualityLibraryType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataQualityLibraryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualityLibraryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataQualitySql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataQualitySql) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
}

var jsonFieldsNameOfDataQualitySql = [2]string{
	0: "type",
	1: "query",
}

// Decode decodes DataQualitySql from json.
func (s *DataQualitySql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualitySql to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataQualitySql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataQualitySql) {
					name = jsonFieldsNameOfDataQualitySql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataQualitySql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualitySql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualitySqlType as json.
func (s DataQualitySqlType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataQualitySqlType from json.
func (s *DataQualitySqlType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataQualitySqlType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataQualitySqlType(v) {
	case DataQualitySqlTypeText:
		*s = DataQualitySqlTypeText
	case DataQualitySqlTypeLibrary:
		*s = DataQualitySqlTypeLibrary
	case DataQualitySqlTypeSQL:
		*s = DataQualitySqlTypeSQL
	case DataQualitySqlTypeCustom:
		*s = DataQualitySqlTypeCustom
	default:
		*s = DataQualitySqlType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataQualitySqlType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataQualitySqlType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Deployment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Deployment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Pods != nil {
			e.FieldStart("pods")
			e.ArrStart()
			for _, elem := range s.Pods {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDeployment = [2]string{
	0: "status",
	1: "pods",
}

// Decode decodes Deployment from json.
func (s *Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Deployment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "pods":
			if err := func() error {
				s.Pods = make([]PodStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PodStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pods = append(s.Pods, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Deployment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployment) {
					name = jsonFieldsNameOfDeployment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Deployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Deployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeploymentStatus as json.
func (s DeploymentStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeploymentStatus from json.
func (s *DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentStatus(v) {
	case DeploymentStatusDeployed:
		*s = DeploymentStatusDeployed
	case DeploymentStatusFailed:
		*s = DeploymentStatusFailed
	case DeploymentStatusPending:
		*s = DeploymentStatusPending
	case DeploymentStatusMissing:
		*s = DeploymentStatusMissing
	case DeploymentStatusUnknown:
		*s = DeploymentStatusUnknown
	default:
		*s = DeploymentStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeploymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Description) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Description) encodeFields(e *jx.Encoder) {
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.Purpose.Set {
			e.FieldStart("purpose")
			s.Purpose.Encode(e)
		}
	}
	{
		if s.Limitations.Set {
			e.FieldStart("limitations")
			s.Limitations.Encode(e)
		}
	}
}

var jsonFieldsNameOfDescription = [3]string{
	0: "usage",
	1: "purpose",
	2: "limitations",
}

// Decode decodes Description from json.
func (s *Description) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Description to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "purpose":
			if err := func() error {
				s.Purpose.Reset()
				if err := s.Purpose.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purpose\"")
			}
		case "limitations":
			if err := func() error {
				s.Limitations.Reset()
				if err := s.Limitations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Description")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Description) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Description) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DvClient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DvClient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
}

var jsonFieldsNameOfDvClient = [2]string{
	0: "name",
	1: "label",
}

// Decode decodes DvClient from json.
func (s *DvClient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DvClient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DvClient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDvClient) {
					name = jsonFieldsNameOfDvClient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DvClient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DvClient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAlgorithmLogsOKApplicationJSON as json.
func (s GetAlgorithmLogsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GetAlgorithmLogsOKApplicationJSON from json.
func (s *GetAlgorithmLogsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAlgorithmLogsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAlgorithmLogsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAlgorithmLogsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAlgorithmLogsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCollaborationSpacesOKApplicationJSON as json.
func (s GetCollaborationSpacesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CollaborationSpace(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetCollaborationSpacesOKApplicationJSON from json.
func (s *GetCollaborationSpacesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCollaborationSpacesOKApplicationJSON to nil")
	}
	var unwrapped []CollaborationSpace
	if err := func() error {
		unwrapped = make([]CollaborationSpace, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CollaborationSpace
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCollaborationSpacesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetCollaborationSpacesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCollaborationSpacesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCollaboratorsOKApplicationJSON as json.
func (s GetCollaboratorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Collaborator(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetCollaboratorsOKApplicationJSON from json.
func (s *GetCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCollaboratorsOKApplicationJSON to nil")
	}
	var unwrapped []Collaborator
	if err := func() error {
		unwrapped = make([]Collaborator, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Collaborator
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetCollaboratorsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCollaboratorsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDataContractsOKApplicationJSON as json.
func (s GetDataContractsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []DataContractSummary(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetDataContractsOKApplicationJSON from json.
func (s *GetDataContractsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDataContractsOKApplicationJSON to nil")
	}
	var unwrapped []DataContractSummary
	if err := func() error {
		unwrapped = make([]DataContractSummary, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DataContractSummary
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDataContractsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDataContractsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDataContractsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDeploymentLogsOKApplicationJSON as json.
func (s GetDeploymentLogsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GetDeploymentLogsOKApplicationJSON from json.
func (s *GetDeploymentLogsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDeploymentLogsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDeploymentLogsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDeploymentLogsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDeploymentLogsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetInvitesOKApplicationJSON as json.
func (s GetInvitesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []jx.Raw(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes GetInvitesOKApplicationJSON from json.
func (s *GetInvitesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInvitesOKApplicationJSON to nil")
	}
	var unwrapped []jx.Raw
	if err := func() error {
		unwrapped = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetInvitesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetInvitesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInvitesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPublicClientOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPublicClientOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("issuer")
		e.Str(s.Issuer)
	}
}

var jsonFieldsNameOfGetPublicClientOK = [1]string{
	0: "issuer",
}

// Decode decodes GetPublicClientOK from json.
func (s *GetPublicClientOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPublicClientOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issuer":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Issuer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPublicClientOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPublicClientOK) {
					name = jsonFieldsNameOfGetPublicClientOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPublicClientOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPublicClientOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFoundError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFoundError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
}

var jsonFieldsNameOfNotFoundError = [1]string{
	0: "error_message",
}

// Decode decodes NotFoundError from json.
func (s *NotFoundError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundError to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFoundError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotFoundError) {
					name = jsonFieldsNameOfNotFoundError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFoundError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ODCSServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ODCSServer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("server")
		e.Str(s.Server)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfODCSServer = [3]string{
	0: "server",
	1: "description",
	2: "environment",
}

// Decode decodes ODCSServer from json.
func (s *ODCSServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ODCSServer to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "server":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Server = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ODCSServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfODCSServer) {
					name = jsonFieldsNameOfODCSServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ODCSServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ODCSServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ODCSServerSum as json.
func (s ODCSServerSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ODCSServerSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ApiServerODCSServerSum:
		e.FieldStart("type")
		e.Str("api")
		{
			s := s.ApiServer
			{
				e.FieldStart("location")
				json.EncodeURI(e, s.Location)
			}
		}
	case CustomServerODCSServerSum:
		e.FieldStart("type")
		e.Str("custom")
		{
			s := s.CustomServer
			{
				if s.Location.Set {
					e.FieldStart("location")
					s.Location.Encode(e)
				}
			}
			{
				if s.Path.Set {
					e.FieldStart("path")
					s.Path.Encode(e)
				}
			}
			{
				if s.Account.Set {
					e.FieldStart("account")
					s.Account.Encode(e)
				}
			}
			{
				if s.Catalog.Set {
					e.FieldStart("catalog")
					s.Catalog.Encode(e)
				}
			}
			{
				if s.Database.Set {
					e.FieldStart("database")
					s.Database.Encode(e)
				}
			}
			{
				if s.Dataset.Set {
					e.FieldStart("dataset")
					s.Dataset.Encode(e)
				}
			}
			{
				if s.Delimiter.Set {
					e.FieldStart("delimiter")
					s.Delimiter.Encode(e)
				}
			}
			{
				if s.EndpointUrl.Set {
					e.FieldStart("endpointUrl")
					s.EndpointUrl.Encode(e)
				}
			}
			{
				if s.Format.Set {
					e.FieldStart("format")
					s.Format.Encode(e)
				}
			}
			{
				if s.Host.Set {
					e.FieldStart("host")
					s.Host.Encode(e)
				}
			}
			{
				if s.Port.Set {
					e.FieldStart("port")
					s.Port.Encode(e)
				}
			}
			{
				if s.Project.Set {
					e.FieldStart("project")
					s.Project.Encode(e)
				}
			}
			{
				if s.Region.Set {
					e.FieldStart("region")
					s.Region.Encode(e)
				}
			}
			{
				if s.RegionName.Set {
					e.FieldStart("regionName")
					s.RegionName.Encode(e)
				}
			}
			{
				if s.Schema.Set {
					e.FieldStart("schema")
					s.Schema.Encode(e)
				}
			}
			{
				if s.ServiceName.Set {
					e.FieldStart("serviceName")
					s.ServiceName.Encode(e)
				}
			}
			{
				if s.StagingDir.Set {
					e.FieldStart("stagingDir")
					s.StagingDir.Encode(e)
				}
			}
			{
				if s.Warehouse.Set {
					e.FieldStart("warehouse")
					s.Warehouse.Encode(e)
				}
			}
		}
	}
}

// Decode decodes ODCSServerSum from json.
func (s *ODCSServerSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ODCSServerSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "api":
					s.Type = ApiServerODCSServerSum
					found = true
				case "custom":
					s.Type = CustomServerODCSServerSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ApiServerODCSServerSum:
		if err := s.ApiServer.Decode(d); err != nil {
			return err
		}
	case CustomServerODCSServerSum:
		if err := s.CustomServer.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ODCSServerSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ODCSServerSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeProviderSettings as json.
func (o OptCodeProviderSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeProviderSettings from json.
func (o *OptCodeProviderSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeProviderSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeProviderSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeProviderSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeProviderSource as json.
func (o OptCodeProviderSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeProviderSource from json.
func (o *OptCodeProviderSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeProviderSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeProviderSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeProviderSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorConfiguration as json.
func (o OptCollaboratorConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollaboratorConfiguration from json.
func (o *OptCollaboratorConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollaboratorConfiguration to nil")
	}
	o.Set = true
	o.Value = make(CollaboratorConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCollaboratorConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCollaboratorConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorCreateConfiguration as json.
func (o OptCollaboratorCreateConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollaboratorCreateConfiguration from json.
func (o *OptCollaboratorCreateConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollaboratorCreateConfiguration to nil")
	}
	o.Set = true
	o.Value = make(CollaboratorCreateConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCollaboratorCreateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCollaboratorCreateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorUpdateConfiguration as json.
func (o OptCollaboratorUpdateConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollaboratorUpdateConfiguration from json.
func (o *OptCollaboratorUpdateConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollaboratorUpdateConfiguration to nil")
	}
	o.Set = true
	o.Value = make(CollaboratorUpdateConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCollaboratorUpdateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCollaboratorUpdateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataConsumerSettings as json.
func (o OptDataConsumerSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataConsumerSettings from json.
func (o *OptDataConsumerSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataConsumerSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataConsumerSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataConsumerSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractUpdateApiVersion as json.
func (o OptDataContractUpdateApiVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataContractUpdateApiVersion from json.
func (o *OptDataContractUpdateApiVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataContractUpdateApiVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataContractUpdateApiVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataContractUpdateApiVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataContractUpdateKind as json.
func (o OptDataContractUpdateKind) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataContractUpdateKind from json.
func (o *OptDataContractUpdateKind) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataContractUpdateKind to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataContractUpdateKind) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataContractUpdateKind) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataProviderSettings as json.
func (o OptDataProviderSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataProviderSettings from json.
func (o *OptDataProviderSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataProviderSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataProviderSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataProviderSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualityItemDimension as json.
func (o OptDataQualityItemDimension) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataQualityItemDimension from json.
func (o *OptDataQualityItemDimension) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataQualityItemDimension to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataQualityItemDimension) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataQualityItemDimension) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualityLibraryType as json.
func (o OptDataQualityLibraryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataQualityLibraryType from json.
func (o *OptDataQualityLibraryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataQualityLibraryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataQualityLibraryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataQualityLibraryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataQualitySqlType as json.
func (o OptDataQualitySqlType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataQualitySqlType from json.
func (o *OptDataQualitySqlType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataQualitySqlType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataQualitySqlType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataQualitySqlType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes Description as json.
func (o OptDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Description from json.
func (o *OptDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnyType as json.
func (o OptNilAnyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnyType from json.
func (o *OptNilAnyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAnyType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AnyType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAnyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAnyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []float64 as json.
func (o OptNilFloat64Array) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Float64(elem)
	}
	e.ArrEnd()
}

// Decode decodes []float64 from json.
func (o *OptNilFloat64Array) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64Array to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]float64, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem float64
		v, err := d.Float64()
		elem = float64(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64Array) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64Array) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Price as json.
func (o OptPrice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Price from json.
func (o *OptPrice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPrice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyCreateLogicalType as json.
func (o OptPropertyCreateLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PropertyCreateLogicalType from json.
func (o *OptPropertyCreateLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPropertyCreateLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPropertyCreateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPropertyCreateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyLogicalType as json.
func (o OptPropertyLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PropertyLogicalType from json.
func (o *OptPropertyLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPropertyLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPropertyLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPropertyLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyUpdateLogicalType as json.
func (o OptPropertyUpdateLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PropertyUpdateLogicalType from json.
func (o *OptPropertyUpdateLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPropertyUpdateLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPropertyUpdateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPropertyUpdateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaCreateLogicalType as json.
func (o OptSchemaCreateLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SchemaCreateLogicalType from json.
func (o *OptSchemaCreateLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaCreateLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaCreateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaCreateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaLogicalType as json.
func (o OptSchemaLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SchemaLogicalType from json.
func (o *OptSchemaLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaUpdateLogicalType as json.
func (o OptSchemaUpdateLogicalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SchemaUpdateLogicalType from json.
func (o *OptSchemaUpdateLogicalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchemaUpdateLogicalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchemaUpdateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchemaUpdateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PodStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PodStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.StatusSince.Set {
			e.FieldStart("status_since")
			s.StatusSince.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ImageIds != nil {
			e.FieldStart("imageIds")
			e.ArrStart()
			for _, elem := range s.ImageIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPodStatus = [4]string{
	0: "name",
	1: "status",
	2: "status_since",
	3: "imageIds",
}

// Decode decodes PodStatus from json.
func (s *PodStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PodStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_since":
			if err := func() error {
				s.StatusSince.Reset()
				if err := s.StatusSince.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_since\"")
			}
		case "imageIds":
			if err := func() error {
				s.ImageIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ImageIds = append(s.ImageIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PodStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPodStatus) {
					name = jsonFieldsNameOfPodStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PodStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PodStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Price) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Price) encodeFields(e *jx.Encoder) {
	{
		if s.PriceAmount.Set {
			e.FieldStart("priceAmount")
			s.PriceAmount.Encode(e)
		}
	}
	{
		if s.PriceCurrency.Set {
			e.FieldStart("priceCurrency")
			s.PriceCurrency.Encode(e)
		}
	}
	{
		if s.PriceUnit.Set {
			e.FieldStart("priceUnit")
			s.PriceUnit.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrice = [3]string{
	0: "priceAmount",
	1: "priceCurrency",
	2: "priceUnit",
}

// Decode decodes Price from json.
func (s *Price) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Price to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "priceAmount":
			if err := func() error {
				s.PriceAmount.Reset()
				if err := s.PriceAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priceAmount\"")
			}
		case "priceCurrency":
			if err := func() error {
				s.PriceCurrency.Reset()
				if err := s.PriceCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priceCurrency\"")
			}
		case "priceUnit":
			if err := func() error {
				s.PriceUnit.Reset()
				if err := s.PriceUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priceUnit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Price")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Price) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Price) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Property) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Property) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.PrimaryKey.Set {
			e.FieldStart("primaryKey")
			s.PrimaryKey.Encode(e)
		}
	}
	{
		if s.PrimaryKeyPosition.Set {
			e.FieldStart("primaryKeyPosition")
			s.PrimaryKeyPosition.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.LogicalTypeOptions != nil {
			e.FieldStart("logicalTypeOptions")
			s.LogicalTypeOptions.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Unique.Set {
			e.FieldStart("unique")
			s.Unique.Encode(e)
		}
	}
	{
		if s.Partitioned.Set {
			e.FieldStart("partitioned")
			s.Partitioned.Encode(e)
		}
	}
	{
		if s.PartitionKeyPosition.Set {
			e.FieldStart("partitionKeyPosition")
			s.PartitionKeyPosition.Encode(e)
		}
	}
	{
		if s.Classification.Set {
			e.FieldStart("classification")
			s.Classification.Encode(e)
		}
	}
	{
		if s.EncryptedName.Set {
			e.FieldStart("encryptedName")
			s.EncryptedName.Encode(e)
		}
	}
	{
		if s.TransformSourceObjects != nil {
			e.FieldStart("transformSourceObjects")
			e.ArrStart()
			for _, elem := range s.TransformSourceObjects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TransformLogic.Set {
			e.FieldStart("transformLogic")
			s.TransformLogic.Encode(e)
		}
	}
	{
		if s.TransformDescription.Set {
			e.FieldStart("transformDescription")
			s.TransformDescription.Encode(e)
		}
	}
	{
		if s.CriticalDataElement.Set {
			e.FieldStart("criticalDataElement")
			s.CriticalDataElement.Encode(e)
		}
	}
	{
		e.FieldStart("_id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfProperty = [21]string{
	0:  "name",
	1:  "physicalType",
	2:  "description",
	3:  "businessName",
	4:  "tags",
	5:  "quality",
	6:  "primaryKey",
	7:  "primaryKeyPosition",
	8:  "logicalType",
	9:  "logicalTypeOptions",
	10: "required",
	11: "unique",
	12: "partitioned",
	13: "partitionKeyPosition",
	14: "classification",
	15: "encryptedName",
	16: "transformSourceObjects",
	17: "transformLogic",
	18: "transformDescription",
	19: "criticalDataElement",
	20: "_id",
}

// Decode decodes Property from json.
func (s *Property) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Property to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "primaryKey":
			if err := func() error {
				s.PrimaryKey.Reset()
				if err := s.PrimaryKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKey\"")
			}
		case "primaryKeyPosition":
			if err := func() error {
				s.PrimaryKeyPosition.Reset()
				if err := s.PrimaryKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKeyPosition\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "logicalTypeOptions":
			if err := func() error {
				s.LogicalTypeOptions = nil
				var elem PropertyLogicalTypeOptions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.LogicalTypeOptions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalTypeOptions\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "unique":
			if err := func() error {
				s.Unique.Reset()
				if err := s.Unique.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique\"")
			}
		case "partitioned":
			if err := func() error {
				s.Partitioned.Reset()
				if err := s.Partitioned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitioned\"")
			}
		case "partitionKeyPosition":
			if err := func() error {
				s.PartitionKeyPosition.Reset()
				if err := s.PartitionKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitionKeyPosition\"")
			}
		case "classification":
			if err := func() error {
				s.Classification.Reset()
				if err := s.Classification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classification\"")
			}
		case "encryptedName":
			if err := func() error {
				s.EncryptedName.Reset()
				if err := s.EncryptedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedName\"")
			}
		case "transformSourceObjects":
			if err := func() error {
				s.TransformSourceObjects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TransformSourceObjects = append(s.TransformSourceObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformSourceObjects\"")
			}
		case "transformLogic":
			if err := func() error {
				s.TransformLogic.Reset()
				if err := s.TransformLogic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformLogic\"")
			}
		case "transformDescription":
			if err := func() error {
				s.TransformDescription.Reset()
				if err := s.TransformDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformDescription\"")
			}
		case "criticalDataElement":
			if err := func() error {
				s.CriticalDataElement.Reset()
				if err := s.CriticalDataElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criticalDataElement\"")
			}
		case "_id":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Property")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProperty) {
					name = jsonFieldsNameOfProperty[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Property) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Property) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.PrimaryKey.Set {
			e.FieldStart("primaryKey")
			s.PrimaryKey.Encode(e)
		}
	}
	{
		if s.PrimaryKeyPosition.Set {
			e.FieldStart("primaryKeyPosition")
			s.PrimaryKeyPosition.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.LogicalTypeOptions != nil {
			e.FieldStart("logicalTypeOptions")
			s.LogicalTypeOptions.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Unique.Set {
			e.FieldStart("unique")
			s.Unique.Encode(e)
		}
	}
	{
		if s.Partitioned.Set {
			e.FieldStart("partitioned")
			s.Partitioned.Encode(e)
		}
	}
	{
		if s.PartitionKeyPosition.Set {
			e.FieldStart("partitionKeyPosition")
			s.PartitionKeyPosition.Encode(e)
		}
	}
	{
		if s.Classification.Set {
			e.FieldStart("classification")
			s.Classification.Encode(e)
		}
	}
	{
		if s.EncryptedName.Set {
			e.FieldStart("encryptedName")
			s.EncryptedName.Encode(e)
		}
	}
	{
		if s.TransformSourceObjects != nil {
			e.FieldStart("transformSourceObjects")
			e.ArrStart()
			for _, elem := range s.TransformSourceObjects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TransformLogic.Set {
			e.FieldStart("transformLogic")
			s.TransformLogic.Encode(e)
		}
	}
	{
		if s.TransformDescription.Set {
			e.FieldStart("transformDescription")
			s.TransformDescription.Encode(e)
		}
	}
	{
		if s.CriticalDataElement.Set {
			e.FieldStart("criticalDataElement")
			s.CriticalDataElement.Encode(e)
		}
	}
}

var jsonFieldsNameOfPropertyCreate = [20]string{
	0:  "name",
	1:  "physicalType",
	2:  "description",
	3:  "businessName",
	4:  "tags",
	5:  "quality",
	6:  "primaryKey",
	7:  "primaryKeyPosition",
	8:  "logicalType",
	9:  "logicalTypeOptions",
	10: "required",
	11: "unique",
	12: "partitioned",
	13: "partitionKeyPosition",
	14: "classification",
	15: "encryptedName",
	16: "transformSourceObjects",
	17: "transformLogic",
	18: "transformDescription",
	19: "criticalDataElement",
}

// Decode decodes PropertyCreate from json.
func (s *PropertyCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyCreate to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "primaryKey":
			if err := func() error {
				s.PrimaryKey.Reset()
				if err := s.PrimaryKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKey\"")
			}
		case "primaryKeyPosition":
			if err := func() error {
				s.PrimaryKeyPosition.Reset()
				if err := s.PrimaryKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKeyPosition\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "logicalTypeOptions":
			if err := func() error {
				s.LogicalTypeOptions = nil
				var elem PropertyCreateLogicalTypeOptions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.LogicalTypeOptions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalTypeOptions\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "unique":
			if err := func() error {
				s.Unique.Reset()
				if err := s.Unique.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique\"")
			}
		case "partitioned":
			if err := func() error {
				s.Partitioned.Reset()
				if err := s.Partitioned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitioned\"")
			}
		case "partitionKeyPosition":
			if err := func() error {
				s.PartitionKeyPosition.Reset()
				if err := s.PartitionKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitionKeyPosition\"")
			}
		case "classification":
			if err := func() error {
				s.Classification.Reset()
				if err := s.Classification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classification\"")
			}
		case "encryptedName":
			if err := func() error {
				s.EncryptedName.Reset()
				if err := s.EncryptedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedName\"")
			}
		case "transformSourceObjects":
			if err := func() error {
				s.TransformSourceObjects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TransformSourceObjects = append(s.TransformSourceObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformSourceObjects\"")
			}
		case "transformLogic":
			if err := func() error {
				s.TransformLogic.Reset()
				if err := s.TransformLogic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformLogic\"")
			}
		case "transformDescription":
			if err := func() error {
				s.TransformDescription.Reset()
				if err := s.TransformDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformDescription\"")
			}
		case "criticalDataElement":
			if err := func() error {
				s.CriticalDataElement.Reset()
				if err := s.CriticalDataElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criticalDataElement\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyCreate) {
					name = jsonFieldsNameOfPropertyCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyCreateLogicalType as json.
func (s PropertyCreateLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PropertyCreateLogicalType from json.
func (s *PropertyCreateLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyCreateLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PropertyCreateLogicalType(v) {
	case PropertyCreateLogicalTypeString:
		*s = PropertyCreateLogicalTypeString
	case PropertyCreateLogicalTypeDate:
		*s = PropertyCreateLogicalTypeDate
	case PropertyCreateLogicalTypeNumber:
		*s = PropertyCreateLogicalTypeNumber
	case PropertyCreateLogicalTypeInteger:
		*s = PropertyCreateLogicalTypeInteger
	case PropertyCreateLogicalTypeObject:
		*s = PropertyCreateLogicalTypeObject
	case PropertyCreateLogicalTypeArray:
		*s = PropertyCreateLogicalTypeArray
	case PropertyCreateLogicalTypeBoolean:
		*s = PropertyCreateLogicalTypeBoolean
	default:
		*s = PropertyCreateLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PropertyCreateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyCreateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyCreateLogicalTypeOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyCreateLogicalTypeOptions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPropertyCreateLogicalTypeOptions = [0]string{}

// Decode decodes PropertyCreateLogicalTypeOptions from json.
func (s *PropertyCreateLogicalTypeOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyCreateLogicalTypeOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PropertyCreateLogicalTypeOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyCreateLogicalTypeOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyCreateLogicalTypeOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyLogicalType as json.
func (s PropertyLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PropertyLogicalType from json.
func (s *PropertyLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PropertyLogicalType(v) {
	case PropertyLogicalTypeString:
		*s = PropertyLogicalTypeString
	case PropertyLogicalTypeDate:
		*s = PropertyLogicalTypeDate
	case PropertyLogicalTypeNumber:
		*s = PropertyLogicalTypeNumber
	case PropertyLogicalTypeInteger:
		*s = PropertyLogicalTypeInteger
	case PropertyLogicalTypeObject:
		*s = PropertyLogicalTypeObject
	case PropertyLogicalTypeArray:
		*s = PropertyLogicalTypeArray
	case PropertyLogicalTypeBoolean:
		*s = PropertyLogicalTypeBoolean
	default:
		*s = PropertyLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PropertyLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyLogicalTypeOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyLogicalTypeOptions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPropertyLogicalTypeOptions = [0]string{}

// Decode decodes PropertyLogicalTypeOptions from json.
func (s *PropertyLogicalTypeOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyLogicalTypeOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PropertyLogicalTypeOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyLogicalTypeOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyLogicalTypeOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.PrimaryKey.Set {
			e.FieldStart("primaryKey")
			s.PrimaryKey.Encode(e)
		}
	}
	{
		if s.PrimaryKeyPosition.Set {
			e.FieldStart("primaryKeyPosition")
			s.PrimaryKeyPosition.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.LogicalTypeOptions != nil {
			e.FieldStart("logicalTypeOptions")
			s.LogicalTypeOptions.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Unique.Set {
			e.FieldStart("unique")
			s.Unique.Encode(e)
		}
	}
	{
		if s.Partitioned.Set {
			e.FieldStart("partitioned")
			s.Partitioned.Encode(e)
		}
	}
	{
		if s.PartitionKeyPosition.Set {
			e.FieldStart("partitionKeyPosition")
			s.PartitionKeyPosition.Encode(e)
		}
	}
	{
		if s.Classification.Set {
			e.FieldStart("classification")
			s.Classification.Encode(e)
		}
	}
	{
		if s.EncryptedName.Set {
			e.FieldStart("encryptedName")
			s.EncryptedName.Encode(e)
		}
	}
	{
		if s.TransformSourceObjects != nil {
			e.FieldStart("transformSourceObjects")
			e.ArrStart()
			for _, elem := range s.TransformSourceObjects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TransformLogic.Set {
			e.FieldStart("transformLogic")
			s.TransformLogic.Encode(e)
		}
	}
	{
		if s.TransformDescription.Set {
			e.FieldStart("transformDescription")
			s.TransformDescription.Encode(e)
		}
	}
	{
		if s.CriticalDataElement.Set {
			e.FieldStart("criticalDataElement")
			s.CriticalDataElement.Encode(e)
		}
	}
}

var jsonFieldsNameOfPropertyUpdate = [20]string{
	0:  "name",
	1:  "physicalType",
	2:  "description",
	3:  "businessName",
	4:  "tags",
	5:  "quality",
	6:  "primaryKey",
	7:  "primaryKeyPosition",
	8:  "logicalType",
	9:  "logicalTypeOptions",
	10: "required",
	11: "unique",
	12: "partitioned",
	13: "partitionKeyPosition",
	14: "classification",
	15: "encryptedName",
	16: "transformSourceObjects",
	17: "transformLogic",
	18: "transformDescription",
	19: "criticalDataElement",
}

// Decode decodes PropertyUpdate from json.
func (s *PropertyUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "primaryKey":
			if err := func() error {
				s.PrimaryKey.Reset()
				if err := s.PrimaryKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKey\"")
			}
		case "primaryKeyPosition":
			if err := func() error {
				s.PrimaryKeyPosition.Reset()
				if err := s.PrimaryKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryKeyPosition\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "logicalTypeOptions":
			if err := func() error {
				s.LogicalTypeOptions = nil
				var elem PropertyUpdateLogicalTypeOptions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.LogicalTypeOptions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalTypeOptions\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "unique":
			if err := func() error {
				s.Unique.Reset()
				if err := s.Unique.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique\"")
			}
		case "partitioned":
			if err := func() error {
				s.Partitioned.Reset()
				if err := s.Partitioned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitioned\"")
			}
		case "partitionKeyPosition":
			if err := func() error {
				s.PartitionKeyPosition.Reset()
				if err := s.PartitionKeyPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partitionKeyPosition\"")
			}
		case "classification":
			if err := func() error {
				s.Classification.Reset()
				if err := s.Classification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classification\"")
			}
		case "encryptedName":
			if err := func() error {
				s.EncryptedName.Reset()
				if err := s.EncryptedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedName\"")
			}
		case "transformSourceObjects":
			if err := func() error {
				s.TransformSourceObjects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TransformSourceObjects = append(s.TransformSourceObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformSourceObjects\"")
			}
		case "transformLogic":
			if err := func() error {
				s.TransformLogic.Reset()
				if err := s.TransformLogic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformLogic\"")
			}
		case "transformDescription":
			if err := func() error {
				s.TransformDescription.Reset()
				if err := s.TransformDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformDescription\"")
			}
		case "criticalDataElement":
			if err := func() error {
				s.CriticalDataElement.Reset()
				if err := s.CriticalDataElement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criticalDataElement\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PropertyUpdateLogicalType as json.
func (s PropertyUpdateLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PropertyUpdateLogicalType from json.
func (s *PropertyUpdateLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyUpdateLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PropertyUpdateLogicalType(v) {
	case PropertyUpdateLogicalTypeString:
		*s = PropertyUpdateLogicalTypeString
	case PropertyUpdateLogicalTypeDate:
		*s = PropertyUpdateLogicalTypeDate
	case PropertyUpdateLogicalTypeNumber:
		*s = PropertyUpdateLogicalTypeNumber
	case PropertyUpdateLogicalTypeInteger:
		*s = PropertyUpdateLogicalTypeInteger
	case PropertyUpdateLogicalTypeObject:
		*s = PropertyUpdateLogicalTypeObject
	case PropertyUpdateLogicalTypeArray:
		*s = PropertyUpdateLogicalTypeArray
	case PropertyUpdateLogicalTypeBoolean:
		*s = PropertyUpdateLogicalTypeBoolean
	default:
		*s = PropertyUpdateLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PropertyUpdateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyUpdateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyUpdateLogicalTypeOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyUpdateLogicalTypeOptions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPropertyUpdateLogicalTypeOptions = [0]string{}

// Decode decodes PropertyUpdateLogicalTypeOptions from json.
func (s *PropertyUpdateLogicalTypeOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyUpdateLogicalTypeOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PropertyUpdateLogicalTypeOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyUpdateLogicalTypeOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyUpdateLogicalTypeOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublishEventOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublishEventOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messageId")
		e.Str(s.MessageId)
	}
}

var jsonFieldsNameOfPublishEventOK = [1]string{
	0: "messageId",
}

// Decode decodes PublishEventOK from json.
func (s *PublishEventOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublishEventOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messageId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MessageId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messageId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublishEventOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublishEventOK) {
					name = jsonFieldsNameOfPublishEventOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublishEventOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublishEventOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublishEventReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublishEventReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfPublishEventReq = [1]string{
	0: "type",
}

// Decode decodes PublishEventReq from json.
func (s *PublishEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublishEventReq to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublishEventReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublishEventReq) {
					name = jsonFieldsNameOfPublishEventReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublishEventReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublishEventReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PublishEventReqAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PublishEventReqAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes PublishEventReqAdditional from json.
func (s *PublishEventReqAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublishEventReqAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublishEventReqAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublishEventReqAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublishEventReqAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Schema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Schema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.PhysicalName.Set {
			e.FieldStart("physicalName")
			s.PhysicalName.Encode(e)
		}
	}
	{
		if s.DataGranularityDescription.Set {
			e.FieldStart("dataGranularityDescription")
			s.DataGranularityDescription.Encode(e)
		}
	}
	{
		e.FieldStart("_id")
		e.Str(s.ID)
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			e.ArrStart()
			for _, elem := range s.Properties {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSchema = [11]string{
	0:  "name",
	1:  "physicalType",
	2:  "description",
	3:  "businessName",
	4:  "tags",
	5:  "quality",
	6:  "logicalType",
	7:  "physicalName",
	8:  "dataGranularityDescription",
	9:  "_id",
	10: "properties",
}

// Decode decodes Schema from json.
func (s *Schema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Schema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "physicalName":
			if err := func() error {
				s.PhysicalName.Reset()
				if err := s.PhysicalName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalName\"")
			}
		case "dataGranularityDescription":
			if err := func() error {
				s.DataGranularityDescription.Reset()
				if err := s.DataGranularityDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataGranularityDescription\"")
			}
		case "_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_id\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = make([]Property, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Property
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Properties = append(s.Properties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Schema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSchema) {
					name = jsonFieldsNameOfSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Schema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Schema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SchemaCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SchemaCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.PhysicalName.Set {
			e.FieldStart("physicalName")
			s.PhysicalName.Encode(e)
		}
	}
	{
		if s.DataGranularityDescription.Set {
			e.FieldStart("dataGranularityDescription")
			s.DataGranularityDescription.Encode(e)
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			e.ArrStart()
			for _, elem := range s.Properties {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSchemaCreate = [10]string{
	0: "name",
	1: "physicalType",
	2: "description",
	3: "businessName",
	4: "tags",
	5: "quality",
	6: "logicalType",
	7: "physicalName",
	8: "dataGranularityDescription",
	9: "properties",
}

// Decode decodes SchemaCreate from json.
func (s *SchemaCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaCreate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "physicalName":
			if err := func() error {
				s.PhysicalName.Reset()
				if err := s.PhysicalName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalName\"")
			}
		case "dataGranularityDescription":
			if err := func() error {
				s.DataGranularityDescription.Reset()
				if err := s.DataGranularityDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataGranularityDescription\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = make([]PropertyCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PropertyCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Properties = append(s.Properties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemaCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSchemaCreate) {
					name = jsonFieldsNameOfSchemaCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SchemaCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaCreateLogicalType as json.
func (s SchemaCreateLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SchemaCreateLogicalType from json.
func (s *SchemaCreateLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaCreateLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SchemaCreateLogicalType(v) {
	case SchemaCreateLogicalTypeObject:
		*s = SchemaCreateLogicalTypeObject
	default:
		*s = SchemaCreateLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaCreateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaCreateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaLogicalType as json.
func (s SchemaLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SchemaLogicalType from json.
func (s *SchemaLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SchemaLogicalType(v) {
	case SchemaLogicalTypeObject:
		*s = SchemaLogicalTypeObject
	default:
		*s = SchemaLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SchemaUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SchemaUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhysicalType.Set {
			e.FieldStart("physicalType")
			s.PhysicalType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BusinessName.Set {
			e.FieldStart("businessName")
			s.BusinessName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quality != nil {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.LogicalType.Set {
			e.FieldStart("logicalType")
			s.LogicalType.Encode(e)
		}
	}
	{
		if s.PhysicalName.Set {
			e.FieldStart("physicalName")
			s.PhysicalName.Encode(e)
		}
	}
	{
		if s.DataGranularityDescription.Set {
			e.FieldStart("dataGranularityDescription")
			s.DataGranularityDescription.Encode(e)
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			e.ArrStart()
			for _, elem := range s.Properties {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSchemaUpdate = [10]string{
	0: "name",
	1: "physicalType",
	2: "description",
	3: "businessName",
	4: "tags",
	5: "quality",
	6: "logicalType",
	7: "physicalName",
	8: "dataGranularityDescription",
	9: "properties",
}

// Decode decodes SchemaUpdate from json.
func (s *SchemaUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "physicalType":
			if err := func() error {
				s.PhysicalType.Reset()
				if err := s.PhysicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalType\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "businessName":
			if err := func() error {
				s.BusinessName.Reset()
				if err := s.BusinessName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "quality":
			if err := func() error {
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "logicalType":
			if err := func() error {
				s.LogicalType.Reset()
				if err := s.LogicalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalType\"")
			}
		case "physicalName":
			if err := func() error {
				s.PhysicalName.Reset()
				if err := s.PhysicalName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalName\"")
			}
		case "dataGranularityDescription":
			if err := func() error {
				s.DataGranularityDescription.Reset()
				if err := s.DataGranularityDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataGranularityDescription\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = make([]PropertyCreate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PropertyCreate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Properties = append(s.Properties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SchemaUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SchemaUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SchemaUpdateLogicalType as json.
func (s SchemaUpdateLogicalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SchemaUpdateLogicalType from json.
func (s *SchemaUpdateLogicalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SchemaUpdateLogicalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SchemaUpdateLogicalType(v) {
	case SchemaUpdateLogicalTypeObject:
		*s = SchemaUpdateLogicalTypeObject
	default:
		*s = SchemaUpdateLogicalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SchemaUpdateLogicalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SchemaUpdateLogicalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
}

var jsonFieldsNameOfUnauthorizedError = [1]string{
	0: "error_message",
}

// Decode decodes UnauthorizedError from json.
func (s *UnauthorizedError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorizedError) {
					name = jsonFieldsNameOfUnauthorizedError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
